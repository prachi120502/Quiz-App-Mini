import Quiz from "../models/Quiz.js";
import mongoose from "mongoose";
import {
  generateMCQ,
  generateTrueFalse,
} from "../services/aiQuestionGenerator.js";
import { validateQuestion } from "../services/contentQualityChecker.js";
import logger from "../utils/logger.js";

// ✅ General MCQ Generator
export const generateQuizQuestions = async (req, res) => {
    logger.info(`Generating ${req.body.numQuestions} ${req.body.questionType} questions for quiz ${req.params.id} on topic "${req.body.topic}"`);
    try {
        const { topic, numQuestions, questionType = "mcq" } = req.body;
        const { id } = req.params;

        if (!topic || !numQuestions) {
            logger.warn("Missing topic or numQuestions for AI question generation");
            return res
                .status(400)
                .json({ error: "Topic and number of questions are required" });
        }

        if (!mongoose.Types.ObjectId.isValid(id)) {
            logger.warn(`Invalid quiz ID for AI question generation: ${id}`);
            return res.status(400).json({ error: "Invalid quiz ID" });
        }

        const quiz = await Quiz.findById(id);
        if (!quiz) {
            logger.warn(`Quiz not found: ${id} for AI question generation`);
            return res.status(404).json({ error: "Quiz not found" });
        }

        const existingQuestions = new Set(
            quiz.questions.map((q) => q.question.trim().toLowerCase())
        );
        let finalQuestions = [];

        // Generate questions with retry logic to ensure we get enough unique questions
        const MAX_ATTEMPTS = 3;
        const GENERATION_MULTIPLIER = 1.5; // Generate 1.5x requested to account for duplicates/invalid

        for (let attempt = 0; attempt < MAX_ATTEMPTS && finalQuestions.length < numQuestions; attempt++) {
            // Calculate how many more questions we need
            const remainingNeeded = numQuestions - finalQuestions.length;
            // Generate extra questions to account for duplicates/invalid ones
            const questionsToGenerate = Math.ceil(remainingNeeded * GENERATION_MULTIPLIER);

            let parsed;
            try {
                if (questionType === "mcq") {
                    parsed = await generateMCQ(topic, questionsToGenerate);
                } else if (questionType === "true_false") {
                    parsed = await generateTrueFalse(topic, questionsToGenerate);
                } else {
                    logger.warn(`Invalid question type for AI question generation: ${questionType}`);
                    return res.status(400).json({ error: "Invalid question type" });
                }
            } catch (error) {
                logger.error(`Error generating questions on attempt ${attempt + 1}:`, error.message);
                if (attempt === MAX_ATTEMPTS - 1) {
                    throw error; // Re-throw on last attempt
                }
                continue; // Try again
            }

            // Filter out duplicates and invalid questions
            const newUnique = parsed.questions.filter((q) => {
                const normalized = q.question.trim().toLowerCase();
                const isUnique = !existingQuestions.has(normalized);
                const isValid = validateQuestion(q);

                if (!isUnique) {
                    logger.debug(`Duplicate question filtered: ${q.question.substring(0, 50)}...`);
                }
                if (!isValid) {
                    logger.debug(`Invalid question filtered: ${q.question.substring(0, 50)}...`);
                }

                return isUnique && isValid;
            });

            // Normalize difficulty and add to final list
            newUnique.forEach((q) => {
                const normalized = q.question.trim().toLowerCase();
                if (!["easy", "medium", "hard"].includes(q.difficulty)) {
                    q.difficulty = "medium";
                }
                existingQuestions.add(normalized);
            });

            finalQuestions.push(...newUnique);

            logger.info(`Attempt ${attempt + 1}: Generated ${parsed.questions.length} questions, ${newUnique.length} unique, ${finalQuestions.length} total collected`);
        }

        if (finalQuestions.length === 0) {
            logger.warn("No new unique questions could be generated by AI after all attempts");
            return res
                .status(400)
                .json({ error: "No new unique questions could be generated. The quiz may already have similar questions, or the AI failed to generate valid questions." });
        }

        // Take only the requested number of questions
        const questionsToAdd = finalQuestions.slice(0, numQuestions);
        quiz.questions.push(...questionsToAdd);
        quiz.totalMarks = quiz.questions.length;
        quiz.passingMarks = Math.ceil(quiz.totalMarks / 2);
        quiz.duration = quiz.questions.length * 2;

        await quiz.save();
        const addedCount = questionsToAdd.length;
        logger.info(`Successfully added ${addedCount} new questions to quiz ${id} (requested: ${numQuestions}, generated: ${finalQuestions.length})`);
        res.json({
            message: `${addedCount} new questions added successfully${addedCount < numQuestions ? ` (requested ${numQuestions}, but only ${addedCount} unique questions could be generated)` : ''}`,
            questions: questionsToAdd,
            requested: numQuestions,
            added: addedCount
        });
    } catch (err) {
        logger.error({ message: "Error generating AI questions", error: err.message, stack: err.stack });
        res.status(500).json({ error: "Internal server error", details: err.message });
    }
};

// ✅ Adaptive MCQ Generator
export const generateAdaptiveQuestions = async (req, res) => {
    logger.info(`Generating ${req.body.numQuestions} adaptive questions for quiz ${req.body.quizId} based on performance: ${req.body.performance}`);
    try {
        const { performance, quizId, numQuestions = 5 } = req.body;

        const quiz = await Quiz.findById(quizId);
        if (!quiz) {
            logger.warn(`Quiz not found: ${quizId} for adaptive question generation`);
            return res.status(404).json({ error: "Quiz not found" });
        }

        const topic = quiz.category;
        const difficulty =
            performance === "low" ? "easy" : performance === "high" ? "hard" : "medium";

        const existingQuestions = new Set(
            quiz.questions.map((q) => q.question.trim().toLowerCase())
        );
        let finalQuestions = [];

        // Generate questions with retry logic to ensure we get enough unique questions
        const MAX_ATTEMPTS = 3;
        const GENERATION_MULTIPLIER = 1.5; // Generate 1.5x requested to account for duplicates/invalid

        for (let attempt = 0; attempt < MAX_ATTEMPTS && finalQuestions.length < numQuestions; attempt++) {
            // Calculate how many more questions we need
            const remainingNeeded = numQuestions - finalQuestions.length;
            // Generate extra questions to account for duplicates/invalid ones
            const questionsToGenerate = Math.ceil(remainingNeeded * GENERATION_MULTIPLIER);

            let parsed;
            try {
                parsed = await generateMCQ(topic, questionsToGenerate, difficulty);
            } catch (error) {
                logger.error(`Error generating adaptive questions on attempt ${attempt + 1}:`, error.message);
                if (attempt === MAX_ATTEMPTS - 1) {
                    throw error; // Re-throw on last attempt
                }
                continue; // Try again
            }

            // Filter out duplicates and invalid questions
            const newUnique = parsed.questions.filter((q) => {
                const normalized = q.question.trim().toLowerCase();
                const isUnique = !existingQuestions.has(normalized);
                const isValid = validateQuestion(q);

                if (!isUnique) {
                    logger.debug(`Duplicate adaptive question filtered: ${q.question.substring(0, 50)}...`);
                }
                if (!isValid) {
                    logger.debug(`Invalid adaptive question filtered: ${q.question.substring(0, 50)}...`);
                }

                return isUnique && isValid;
            });

            // Normalize difficulty and add to final list
            newUnique.forEach((q) => {
                const normalized = q.question.trim().toLowerCase();
                if (!["easy", "medium", "hard"].includes(q.difficulty)) {
                    q.difficulty = difficulty; // Use the requested difficulty if not set
                }
                existingQuestions.add(normalized);
            });

            finalQuestions.push(...newUnique);

            logger.info(`Attempt ${attempt + 1}: Generated ${parsed.questions.length} adaptive questions, ${newUnique.length} unique, ${finalQuestions.length} total collected`);
        }

        if (finalQuestions.length === 0) {
            logger.warn("No new unique adaptive questions could be generated by AI after all attempts");
            return res
                .status(400)
                .json({ error: "No new unique adaptive questions could be generated. The quiz may already have similar questions, or the AI failed to generate valid questions." });
        }

        // Take only the requested number of questions
        const questionsToAdd = finalQuestions.slice(0, numQuestions);
        quiz.questions.push(...questionsToAdd);
        quiz.totalMarks = quiz.questions.length;
        quiz.duration = quiz.questions.length * 2;
        quiz.passingMarks = Math.ceil(quiz.totalMarks / 2);

        await quiz.save();
        const addedCount = questionsToAdd.length;
        logger.info(`Successfully added ${addedCount} new adaptive questions to quiz ${quizId} (requested: ${numQuestions}, generated: ${finalQuestions.length})`);
        res.json({
            message: `${addedCount} adaptive questions added successfully${addedCount < numQuestions ? ` (requested ${numQuestions}, but only ${addedCount} unique questions could be generated)` : ''}`,
            questions: questionsToAdd,
            requested: numQuestions,
            added: addedCount
        });
    } catch (err) {
        logger.error({ message: "Error generating adaptive AI questions", error: err.message, stack: err.stack });
        res.status(500).json({ error: "Internal server error", details: err.message });
    }
};
